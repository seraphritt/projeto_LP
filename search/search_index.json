{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wiki do Projeto","text":""},{"location":"#integrantes","title":"Integrantes","text":"<ul> <li>Bruno Berto de Oliveira Ribeiro (200061089)</li> <li>Isaque Augusto da Silva Santos (190089245)</li> <li>Moises de Ara\u00fajo Altounian (200069306)</li> <li>Pedro Cesar Ribeiro Passos (180139312)</li> <li>Tiago Cabral de Faria (160146712)</li> </ul> <p> Bruno Berto de Oliveira Ribeiro Isaque Augusto da Silva Santos Moises de Ara\u00fajo Altounian Pedro Cesar Ribeiro Passos Tiago Cabral de Faria <p></p>"},{"location":"#sobre-o-projeto","title":"Sobre o Projeto","text":"Este projeto envolve a cria\u00e7\u00e3o e implementa\u00e7\u00e3o de uma criptomoeda utilizando blockchain em Rust. A *blockchain* serve como o hist\u00f3rico para todas as transa\u00e7\u00f5es efetuadas pelos usu\u00e1rios da criptomoeda, garantindo seguran\u00e7a e imutabilidade dos dados transacionais.   A linguagem foi selecionada devido \u00e0s suas caracter\u00edsticas em termos de seguran\u00e7a, efici\u00eancia de concorr\u00eancia e alto desempenho.  <p>Link para o reposit\u00f3rio do projeto: https://github.com/seraphritt/projeto_LP</p>"},{"location":"0_introducao/","title":"Introdu\u00e7\u00e3o","text":"Implementar uma criptomoeda \u00e9 um exemplo de projeto complexo que demonstra, de maneira eficaz, como as premissas de performance e seguran\u00e7a de uma linguagem de programa\u00e7\u00e3o s\u00e3o de importante escolha para atingir o \u00eaxito necess\u00e1rio na aplica\u00e7\u00e3o de um projeto computacional. Para que seja poss\u00edvel desenvolver um sistema de tamanha complexidade, \u00e9 necess\u00e1rio que seja escolhida uma linguagem alinhada com o objetivo de compreender e resolver as premissas e desafios t\u00e9cnicos propostos.    Neste cen\u00e1rio, Rust se destaca, principalmente por sua capacidade de garantir alto n\u00edvel de seguran\u00e7a de mem\u00f3ria e desempenho eficiente, caracter\u00edsticas essenciais para que se chegue ao encontro dos objetivos colocados. Sua abordagem \u00fanica, no contexto do gerenciamento de mem\u00f3ria, permite melhor controle de recursos e tratamento de erros, tornando esta a linguagem ideal para o desenvolvimento do projeto."},{"location":"1.1_projeto/","title":"Sobre o Projeto","text":""},{"location":"1.1_projeto/#premissas-da-linguagem-e-sua-aplicabilidade","title":"Premissas da Linguagem e sua Aplicabilidade","text":""},{"location":"1.1_projeto/#seguranca-de-memoria","title":"Seguran\u00e7a de Mem\u00f3ria","text":"<ul> <li> <p>Relev\u00e2ncia: Em um projeto de criptomoeda, a seguran\u00e7a \u00e9 absolutamente cr\u00edtica. Falhas de seguran\u00e7a podem resultar em perdas financeiras significativas para os usu\u00e1rios e descredibilidade da criptomoeda, bem como da organiza\u00e7\u00e3o respons\u00e1vel pela mesma.</p> </li> <li> <p>Implementa\u00e7\u00e3o: Rust garante seguran\u00e7a de mem\u00f3ria atrav\u00e9s de seu sistema \u00fanico de propriedade (ownership) e empr\u00e9stimo (borrowing). Isso elimina preocupa\u00e7\u00f5es comuns como vulnerabilidades de buffer overflow, vazamento de mem\u00f3ria e data races, proporcionando uma base s\u00f3lida para a implementa\u00e7\u00e3o segura de uma criptomoeda.</p> </li> </ul>"},{"location":"1.1_projeto/#performance","title":"Performance","text":"<ul> <li> <p>Relev\u00e2ncia: Criptomoedas demandam alta performance, tanto para o processamento de transa\u00e7\u00f5es quanto para a minera\u00e7\u00e3o de blocos.</p> </li> <li> <p>Implementa\u00e7\u00e3o: Rust oferece performance compar\u00e1vel a linguagens de baixo n\u00edvel como C e C++, permitindo controle direto e seguro sobre a aloca\u00e7\u00e3o de mem\u00f3ria e otimiza\u00e7\u00f5es pelo compilador.</p> </li> </ul>"},{"location":"1.1_projeto/#concorrencia-segura","title":"Concorr\u00eancia Segura","text":"<ul> <li> <p>Relev\u00e2ncia: Transa\u00e7\u00f5es com criptomoedas envolvem m\u00faltiplos agentes operando simultaneamente. Portanto, \u00e9 importante garantir que opera\u00e7\u00f5es concorrentes sejam seguras.</p> </li> <li> <p>Implementa\u00e7\u00e3o: Rust oferece primitivas seguras para concorr\u00eancia, como tipos Send e Sync, que garantem a seguran\u00e7a de opera\u00e7\u00f5es concorrentes sem comprometer a performance. Isso assegura que a blockchain da criptomoeda possa lidar com transa\u00e7\u00f5es concorrentes de forma eficiente e sem riscos de inconsist\u00eancias.</p> </li> </ul>"},{"location":"1.1_projeto/#abstracao-sem-overhead","title":"Abstra\u00e7\u00e3o sem Overhead","text":"<ul> <li> <p>Relev\u00e2ncia: Desenvolver uma criptomoeda requer abstra\u00e7\u00f5es de alto n\u00edvel para lidar com complexidades como transa\u00e7\u00f5es, contratos inteligentes e valida\u00e7\u00e3o de blocos.</p> </li> <li> <p>Implementa\u00e7\u00e3o: Rust permite abstra\u00e7\u00f5es poderosas e eficientes atrav\u00e9s de mecanismos como traits, enums e pattern matching. Isso facilita a implementa\u00e7\u00e3o de algoritmos criptogr\u00e1ficos complexos e estruturas de dados customizadas, sem introduzir overheads desnecess\u00e1rios que poderiam impactar negativamente a performance da rede.</p> </li> </ul>"},{"location":"1.1_projeto/#usuario-caracteristico","title":"Usu\u00e1rio Caracter\u00edstico","text":"Desenvolvedores e engenheiros com experi\u00eancia em linguagens como C, C++ e que desejam desenvolver uma aplica\u00e7\u00e3o que exige seguran\u00e7a, performance e escabilidade."},{"location":"1.1_projeto/#dominio-de-aplicacao","title":"Dom\u00ednio de Aplica\u00e7\u00e3o","text":"Sistemas Operacionais (Redox OS), compiladores, sistemas embarcados, WebAssembly, Ferramnetas que exigem seguran\u00e7a e controle de mem\u00f3ria."},{"location":"1.2_sobreBlockchain/","title":"Sobre a blockchain","text":""},{"location":"1.2_sobreBlockchain/#criptomoeda","title":"Criptomoeda","text":"Para que seja o conceito da blockchain, introduziremos, primeiramente, o conceito de uma criptomoeda.   Uma criptomoeda \u00e9 uma forma de dinheiro digital que, utilizando criptografia, garante a seguran\u00e7a de transa\u00e7\u00f5es e o controle da emiss\u00e3o de moedas. Diferentemente das moedas tradicionais, as criptomoedas operam em um sistema descentralizado, o que permite a elimina\u00e7\u00e3o de intermedi\u00e1rios financeiros. Cada transa\u00e7\u00e3o \u00e9 realizada em um bloco da blockchain e essas moedas podem ser utilizadas para cumprir uma variedade de prop\u00f3sitos, como compras de produtos online, investimentos, compras de ativos e transfer\u00eancia de valor monet\u00e1rio entre indiv\u00edduos."},{"location":"1.2_sobreBlockchain/#blockchain","title":"Blockchain","text":"A blockchain \u00e9 um registro p\u00fablico de todas as transa\u00e7\u00f5es realizadas em uma rede espec\u00edfica, estruturadas em blocos encadeados que garantem transpar\u00eancia e seguran\u00e7a. Cada um dos blocos cont\u00e9m um conjunto de transa\u00e7\u00f5es, sendo ligados - de maneira criptografada - ao bloco anterior, formando uma cadeia cont\u00ednua. Com isso, qualquer tentativa de modificar informa\u00e7\u00f5es anteriores se torna um processo extremamente complicado, visto que, para isso, \u00e9 necess\u00e1ria a altera\u00e7\u00e3o de todos os blocos que vem em sequ\u00eancia."},{"location":"1.2_sobreBlockchain/#entendendo-uma-blockchain","title":"Entendendo uma Blockchain:","text":"<ul> <li> <p>Criptografia De Chave P\u00fablica: T\u00e9cnica que utiliza um par de chaves criptogr\u00e1ficas - uma p\u00fablica e uma privada.</p> <ul> <li>Chave p\u00fablica: utilizada para criptografar dados, tornando-os acess\u00edveis apenas para quem possui a chave privada correspondente.</li> <li>Chave privada: utilizada para decifrar os dados criptografado, garantindo que apenas o destinat\u00e1rio leg\u00edtimo possa ler as mensagens.</li> </ul> </li> <li> <p>Algoritmo De Consenso: utilizado em uma blockchain para garantir que todos os participantes da rede concordem sobre o estado atual do sistema de maneira descentralizada. Diferentes algoritmos de consenso desempenham pap\u00e9is variados na valida\u00e7\u00e3o das transa\u00e7\u00f5es:</p> <ul> <li>Proof of Work (PoW): em que os participantes resolvem problemas computacionais complexos para validar transa\u00e7\u00f5es.</li> <li>Proof of Stake (PoS): onde a validade das transa\u00e7\u00f5es \u00e9 determinada pela quantidade de moeda mantida pelos participantes.</li> </ul> </li> </ul>"},{"location":"1.2_sobreBlockchain/#funcionamento-da-blockchain-implementada-no-projeto","title":"Funcionamento da blockchain implementada no projeto","text":"<p>Por meio do BlockchainManager, o servidor utiliza de duas threads principais:</p> <ul> <li>A thread mineradora, que a partir de um hash inicial chamado proof executa o algoritmo de proof of work para minerar o pr\u00f3ximo bloco.</li> <li>A segunda thread, que, em paralelo \u00e0 primeira, recebe transa\u00e7\u00f5es da criptomoeda em um bloco auxiliar.</li> </ul>  Quando o processo e minera\u00e7\u00e3o termina, as transi\u00e7\u00f5es s\u00e3o efetivadas no bloco e o processo recome\u00e7a. Nesse per\u00edodo de tempo, o cliente pode pedir informa\u00e7\u00f5es das transa\u00e7\u00f5es feita pela carteira (wallet) para saber a quantidade de dinheiro dispon\u00edvel. Assim, pode fazer novas transa\u00e7\u00f5es.  <p> </p>"},{"location":"2.1_rust/","title":"Hist\u00f3ria da linguagem Rust","text":""},{"location":"2.1_rust/#origens-e-motivacao-inicial","title":"Origens e Motiva\u00e7\u00e3o Inicial","text":"Rust foi criada por Graydon Hoare, enquanto trabalhava na Mozilla, no ano de 2006. A motiva\u00e7\u00e3o por tr\u00e1s do desenvolvimento desta linguagem de programa\u00e7\u00e3o era desenvolver uma linguagem que oferecesse alto n\u00edvel de seguran\u00e7a de mem\u00f3ria, rica checagem de tipos e suporte \u00e0 concorr\u00eancia, sem a necessidade de um coletor de lixo. A linguagem foi projetada tendo em vista uma crescente necessidade de uma alternativa s\u00f3lida e eficiente \u00e0s tradicionais linguagens de sistemas, como C e C++.   Rust incorporou influ\u00eancias de linguagens funcionais, incluindo conceitos como a imutabilidade e as fun\u00e7\u00f5es de alta ordem, al\u00e9m de tipos alg\u00e9bricos complexos (como a lista individualmente ligada). Estes conceitos integrados s\u00e3o de extrema import\u00e2ncia para a linguagem, j\u00e1 que promovem pr\u00e1ticas de programa\u00e7\u00e3o que evitam erros comuns em outras linguagens."},{"location":"2.1_rust/#lancamento-e-primeiras-versoes","title":"Lan\u00e7amento e Primeiras Vers\u00f5es","text":"O primeiro an\u00fancio p\u00fablico de Rust ocorreu em 2010, destacando a linguagem como uma solu\u00e7\u00e3o para a programa\u00e7\u00e3o de sistemas, com foco em seguran\u00e7a, concorr\u00eancia e performance.    A partir de 2011, o projeto come\u00e7ou a ganhar popularidade e atrair a aten\u00e7\u00e3o da comunidade de desenvolvedores, devido \u00e0 sua proposta inovadora. Eventualmente, em 2015, a linguagem atingiu um marco importante: o lan\u00e7amento de sua vers\u00e3o 1.0, que comprovou sua maturidade e estabilidade para produ\u00e7\u00e3o.   Desde sua vers\u00e3o inicial, Rust passou por v\u00e1rias itera\u00e7\u00f5es e melhorias significativas. Recursos como o sistema de tipos avan\u00e7ado, o sistema de propriedade e empr\u00e9stimos (ownership e borrowing) e o lifetime checker foram desenvolvidos para garantir seguran\u00e7a e prevenir erros relacionados \u00e0 mem\u00f3ria."},{"location":"2.1_rust/#versoes-recentes-e-evolucao","title":"Vers\u00f5es Recentes e Evolu\u00e7\u00e3o","text":"Atualmente, a linguagem continua evoluindo, com uma comunidade crescente e ativa e um ciclo de desenvolvimento regular, com o lan\u00e7amento frequente de novas vers\u00f5es e melhorias. O ecossistema de Rust est\u00e1 em frequente expans\u00e3o, com direito a adi\u00e7\u00e3o de novas ferramentas como o Cargo (gerenciador de pacotes), al\u00e9m de uma vasta gama de bibliotecas e funcionalidades dispon\u00edveis para desenvolvedores.   A linguagem tem sido adotada em uma variedade de aplica\u00e7\u00f5es, desde o desenvolvimento de sistemas operacionais at\u00e9 a cria\u00e7\u00e3o de aplicativos para a web. Rust se destaca por sua capacidade de oferecer bons \u00edndices de desempenho e confiabilidade, consolidando sua posi\u00e7\u00e3o como linguagem de escolha para projetos que exigem tais caracter\u00edsticas.   Al\u00e9m disso, Rust \u00e9 suportada por uma comunidade engajada, contando com o respaldo de grandes empresas, organiza\u00e7\u00f5es e desenvolvedores de destaque, o que contribui com sua cont\u00ednua evolu\u00e7\u00e3o e amplia a possibilidade de suas aplica\u00e7\u00f5es no contexto do desenvolvimento de software."},{"location":"2.2_sobreRust/","title":"Sobre Rust","text":""},{"location":"2.2_sobreRust/#no-que-consiste-a-linguagem-rust","title":"No que consiste a linguagem Rust?","text":"Rust \u00e9 uma linguagem de programa\u00e7\u00e3o compilada, multiparadigma  (suporta diferentes paradigmas de programa\u00e7\u00e3o, como programa\u00e7\u00e3o imperativa, funcional, orientada a objetos, ...), com foco principal no desempenho e na seguran\u00e7a do sistema. Com um rico sistema de tipos - que podem ser declarados explicitamente ou inferidos pelo compilador - esta linguagem oferece bom equil\u00edbrio entre seguran\u00e7a e perfomance. Seu principal diferencial est\u00e1 em seu m\u00e9todo inovador de gerenciamento de mem\u00f3ria e em seu robusto compilador, que detecta erros que interfiram na aplica\u00e7\u00e3o de projetos em tempo de compila\u00e7\u00e3o."},{"location":"2.2_sobreRust/#gerenciamento-da-memoria","title":"Gerenciamento da mem\u00f3ria","text":"Algumas linguagens utilizam coletor de lixo para gerenciar a mem\u00f3ria. Em outras (como C), o programador deve alocar e liberar mem\u00f3ria de forma expl\u00edcita. Para corrigir erros relacionados ao vazamento de dados, Rust se prop\u00f5e a implementar uma novo m\u00e9todo, atrav\u00e9s de seu sistema \u00fanico de propriedade (ownership) e empr\u00e9stimo (borrowing):"},{"location":"2.2_sobreRust/#ownership","title":"Ownership","text":"Sistema de posse baseado em um conjunto de regras, verificadas em tempo de compila\u00e7\u00e3o. Cada valor em Rust \u00e9 associado a uma \u00fanica vari\u00e1vel (owner). Quando essa vari\u00e1vel sai do escopo, a mem\u00f3ria alocada a ela \u00e9 automaticamente liberada. Esse processo \u00e9 eficiente e ocorre em tempo de compila\u00e7\u00e3o, o que reduz a possibilidade de vazamentos de mem\u00f3ria e outros erros relacionados."},{"location":"2.2_sobreRust/#borrowing","title":"Borrowing","text":"M\u00e9todo que permite que uma vari\u00e1vel seja acessada por refer\u00eancia sem perder sua propriedade (ownership). Este m\u00e9todo garante que a mem\u00f3ria seja gerenciada de forma segura e eficiente, evitando problemas como data races e garantindo maior confiabilidade comparado a linguagens como C."},{"location":"2.2_sobreRust/#partes-da-memoria","title":"Partes da mem\u00f3ria","text":"Visto que a linguagem Rust utiliza um m\u00e9todo distinto de gerenciamento e armazenamento de mem\u00f3ria, \u00e9 interessante pontuar suas principais \u00e1reas de armazenamento: a pilha (stack) e o heap:"},{"location":"2.2_sobreRust/#pilha-stack","title":"Pilha (Stack)","text":"Estrutura de mem\u00f3ria que segue a l\u00f3gica \"Last In, First Out\" (o \u00faltimo dado a ser inserido \u00e9 o primeiro a ser removido). Esta importante estrutura tem como principais caracter\u00edsticas:  <ul> <li>Acesso R\u00e1pido: devido a seu m\u00e9todo de aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria, a pilha oferece um acesso muito mais r\u00e1pido aos dados que a mem\u00f3ria Heap.</li> <li>Tamanho Fixo: Os dados armazenados na pilha devem ter um tamanho fixo e conhecido em tempo de compila\u00e7\u00e3o. Uma vez alocados, estes dados n\u00e3o podem mudar de tamanho. Por isso, \u00e9 ideal para dados de tamanho fixo e tempor\u00e1rios, como vari\u00e1veis locais e chamadas de fun\u00e7\u00f5es. Esta natureza dos dados permite uma r\u00e1pida e eficiente gest\u00e3o dos mesmos.</li> </ul>"},{"location":"2.2_sobreRust/#heap","title":"Heap","text":"\u00c1rea de mem\u00f3ria que permite a aloca\u00e7\u00e3o din\u00e2mica e flex\u00edvel de dados. Ao contr\u00e1rio da pilha, esta parte da mem\u00f3ria pode armazenar dados de tamanho vari\u00e1vel. Esta estrutura tem como principais caracter\u00edsticas:  <ul> <li>Acesso mais lento: A aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria no heap s\u00e3o mais lentas que na pilha. O sistema operacional \u00e9 respons\u00e1vel por encontrar um bloco de mem\u00f3ria suficientemente grande e alocar o espa\u00e7o desejado, retornando um ponteiro para este local.</li> <li>Aloca\u00e7\u00e3o Din\u00e2mica: Para armazenar dados cuja quantidade e tamanho n\u00e3o s\u00e3o conhecidos em tempo de compila\u00e7\u00e3o, a mem\u00f3ria heap \u00e9 a mais indicada. Programas que necessitam utilizar dados que possuem tamanho que pode ser alterado devem fazer uso desta parte da mem\u00f3ria.</li> <li>Armazenamento de Ponteiros: O ponteiro retornado pelo heap \u00e9 armazenado na pilha. Assim, a pilha consegue controlar, de maneira mais r\u00e1pida e eficaz, o acesso aos ponteiros para esses dados.</li> </ul>  Em resumo, a pilha e o heap t\u00eam caracter\u00edsticas e prop\u00f3sitos distintos. Por\u00e9m, ambas s\u00e3o essenciais para a gest\u00e3o eficiente da mem\u00f3ria em Rust. A escolha entre qual \u00e1rea da mem\u00f3ria utilizar ir\u00e1 depender dos requisitos espec\u00edficos de cada programa. A escolha de uso, feita pelo desenvolvedor, ir\u00e1 influenciar diretamente a efici\u00eancia e o desempenho do c\u00f3digo."},{"location":"2.2_sobreRust/#por-que-utilizar-rust","title":"Por que utilizar Rust?","text":""},{"location":"2.2_sobreRust/#seguranca","title":"Seguran\u00e7a","text":"<ul> <li>Sistema de tipos poderoso que previne erros comuns, como null pointer dereferences.</li> <li>Controle rigoroso sobre o gerenciamento de mem\u00f3ria, evitando vazamentos e corrup\u00e7\u00e3o de mem\u00f3ria.</li> <li>Sem\u00e2ntica de propriedade e sistema de empr\u00e9stimo que impede falhas de acesso concorrente (race conditions) e compartilhamento inseguro de dados.</li> <li>Uso extensivo de \"Traits\" para garantir comportamentos padronizados e seguros em estruturas de dados e opera\u00e7\u00f5es.</li> </ul>"},{"location":"2.2_sobreRust/#desempenho","title":"Desempenho","text":"<ul> <li>Efici\u00eancia na gest\u00e3o da mem\u00f3ria, impedindo que data races ocorram.</li> <li>Mem\u00f3ria com melhor desempenho.</li> <li>Abstra\u00e7\u00f5es de custo zero, garantindo maior produtividade sem prejudicar a perfomance.</li> <li>An\u00e1lise e compila\u00e7\u00e3o do c\u00f3digo feita em tempo de compila\u00e7\u00e3o.</li> </ul>"},{"location":"3_construtores/","title":"Construtores","text":""},{"location":"3_construtores/#variaveis-e-mutabilidade","title":"Vari\u00e1veis e Mutabilidade","text":"<p>Em Rust, as vari\u00e1veis s\u00e3o imut\u00e1veis por padr\u00e3o. Isso permite que o c\u00f3digo seja mais seguro. Por\u00e9m, o desenvolvedor pode declarar as vari\u00e1veis como mut\u00e1veis, explicitamente, caso deseje.</p> <pre><code>fn main () {\n  let x = 5; // vari\u00e1vel imut\u00e1vel\n  println!(\"O valor de x \u00e9: {}\", x);\n  let mut y = 10; // vari\u00e1vel mut\u00e1vel\n  y = 20; // Se tentarmos aplicar essa opera\u00e7\u00e3o em x, teremos o erro: \"cannot assign twice to immutable variable\"\n  println!(\"O valor de y \u00e9: {}\", y);\n}\n</code></pre>"},{"location":"3_construtores/#tipos-primitivos","title":"Tipos primitivos","text":"Rust possui um rico sistema de tipos primitivos, que s\u00e3o verificados em tempo de compila\u00e7\u00e3o. Estes tipos podem ser declarados explicitamente ou inferidos pelo compilador. Alguns deles, s\u00e3o:  <ul> <li>Inteiro : Em Rust, os inteiros (int) podem, em sua declara\u00e7\u00e3o, indicar o valor associado com base em seu tamanho. Al\u00e9m disso, pode ser declarado como signed (positivos e negativos) ou unsigned (apenas positivos).</li> </ul> <ul> <li> <p>Flutuante: N\u00fameros com casas decimais. Possui dois tipos primitivos que podem ser utilizados: f32 (32 bits) e f64 (64 bits)</p> </li> <li> <p>Booleano: Indica verdadeiro ou falso.</p> </li> <li> <p>Caractere: O char \u00e9 o tipo mais primitivo da linguagem. Referenciado por aspas simples.</p> </li> </ul>"},{"location":"3_construtores/#tipos-compostos","title":"Tipos compostos","text":"<ul> <li>Tuplas: Forma de agrupar v\u00e1rios valores de tipos diferentes em uma s\u00f3 vari\u00e1vel</li> </ul> <pre><code>fn main () {\n  let tupla: (f32, f64, u8) = (30.0, 3.5, 1); // a tupla pode armazenar diferentes tipos primitivos\n\n  let (a, b, c) = tupla; // com esse m\u00e9todo, atribu\u00edmos a,b e c aos valores da tupla\n}\n</code></pre> <ul> <li>Matriz: Forma de ter v\u00e1rios valores em uma cole\u00e7\u00e3o com tipo \u00fanico.</li> </ul> <pre><code>fn main () {\n    let matriz = [1, 2, 3, 4, 5]; // os dados devem ser do mesmo tipo\n\n    let primeiro = matriz[0]; // acesso a valores da matriz\n}\n</code></pre>"},{"location":"3_construtores/#operadores","title":"Operadores","text":"<p>Rust oferece operadores relacionais, l\u00f3gicos e aritm\u00e9ticos, similares aos de outras linguagens como C, C++ e Java:</p> <ul> <li>Relacionais: ==, !=, &gt;, &lt;, &gt;=, &lt;=</li> <li>L\u00f3gicos: &amp;&amp;, ||, !</li> <li>Aritm\u00e9ticos: +, -, *, /, %</li> </ul>"},{"location":"3_construtores/#comandos","title":"Comandos","text":"<p>Os comandos de controle de fluxo em Rust s\u00e3o semelhantes aos de C e Java, incluindo:</p> <ul> <li>Condicionais: if, else, else if</li> <li>Itera\u00e7\u00e3o: for, while, loop</li> <li>Controle de fluxo: break, continue, return, match</li> </ul>"},{"location":"3_construtores/#palavras-reservadas","title":"Palavras reservadas","text":"<p>Palavras que podem ser utilizadas apenas em seu contexto correto. N\u00e3o podem ser utilizadas como nomes de itens, vari\u00e1veis, par\u00e2metros e etc.</p> <p> </p>  Al\u00e9m destas palavras, ainda temos, em Rust, a presen\u00e7a de outras palavras reservadas. Estas, especificamenteme, ainda n\u00e3o tem seu uso definido pela linguagem, mas est\u00e3o reservadas para uso futuro. S\u00e3o elas: abstract, become, box, do, final, macro, override, priv, typeof, unsized, virtual, yield."},{"location":"3_construtores/#modificadores-de-acesso","title":"Modificadores de acesso","text":"Por padr\u00e3o, a visibilidade de declara\u00e7\u00f5es em Rust \u00e9 privada. Para torn\u00e1-la p\u00fablica, o desenvolvedor deve utilizar a palavra-chave \"pub\", identificando o escopo em que deseja que a vari\u00e1vel ou m\u00e9todo seja p\u00fablico. As regras para isso s\u00e3o:  <ul> <li>pub(in path): faz o item vis\u00edvel dentro do path fornecido. path deve ser um m\u00f3dulo ancestral deste item</li> <li>pub(crate): torna o item vis\u00edvel dentro da caixa atual</li> <li>pub(super): torna o item vis\u00edvel para o m\u00f3dulo pai. Equivale a pub(in super).</li> <li>pub(self): torna o item vis\u00edvel para o m\u00f3dulo atual. Equivale a pub(in self).</li> </ul> <pre><code>struct PrivateStruct { // declara\u00e7\u00e3o padr\u00e3o -&gt; privado\n    field: i32,\n}\n\npub struct PublicStruct { // declara\u00e7\u00e3o alterada para p\u00fablica\n    pub field: i32,\n}\n</code></pre>"},{"location":"3_construtores/#tratamento-de-erros","title":"Tratamento de Erros","text":"Rust adota um modelo de tratamento de erros que, em compara\u00e7\u00e3o com outras linguagens, \u00e9 distinto e rigoroso. Em vez de usar exce\u00e7\u00f5es, Rust utiliza enums e tipos de retorno espec\u00edficos para garantir que todos os erros poss\u00edveis sejam tratados de forma expl\u00edcita.  <p>Em Rust, n\u00e3o h\u00e1 null nem exceptions e separa os erros em duas categorias:</p> <ul> <li>Recuper\u00e1vel: programa consegue tratar e continuar funcionando, podendo ser retornado pela fun\u00e7\u00e3o de onde ocorreu. Fun\u00e7\u00f5es com erros recuper\u00e1veis retornam uma enumera\u00e7\u00e3o Result que referencia dois casos: um deles \u00e9 o tipo do retorno em caso de sucesso e o outro, em caso de fracasso. </li> <li>Irrecuper\u00e1vel: o programa n\u00e3o consegue tratar e deve encerrar sua execu\u00e7\u00e3o imediatamente.</li> </ul> <p>A verifica\u00e7\u00e3o de erros em Rust \u00e9 fortemente incentivada por meio do uso do operador match, que permite ao desenvolvedor lidar de maneira abrangente com os resultados:</p> <pre><code>match divide(10.0, 2.0) {\n  Ok(resultado) =&gt; println!(\"Resultado: {}\", resultado),\n  Err(erro) =&gt; println!(\"Erro: {}\", erro),\n}\n</code></pre> <p>Dessa forma, a linguagem de programa\u00e7\u00e3o garante que os desenvolvedores considerem todas as poss\u00edveis situa\u00e7\u00f5es de erro.</p>"},{"location":"4_legibilidade/","title":"Legibilidade","text":""},{"location":"4_legibilidade/#simplicidade-global","title":"Simplicidade Global","text":"<p>Rust tem uma boa simplicidade global por possuir uma estrutura bem definida na defini\u00e7\u00e3o de vari\u00e1veis e execu\u00e7\u00e3o de opera\u00e7\u00f5es.</p> <p>Em Rust:</p> <pre><code>fn main() {\n    let mut x = 5; // declara\u00e7\u00e3o e inicializa\u00e7\u00e3o de uma vari\u00e1vel mut\u00e1vel\n    x += 2; // incremento\n    println!(\"O valor de x \u00e9: {}\", x); // sa\u00edda de texto\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int x = 5; // declara\u00e7\u00e3o e inicializa\u00e7\u00e3o de uma vari\u00e1vel\n    x += 2; // incremento\n    std::cout &lt;&lt; \"O valor de x \u00e9: \" &lt;&lt; x &lt;&lt; std::endl; // sa\u00edda de texto\n    return 0;\n}\n</code></pre> Ambos exemplos s\u00e3o relativamente simples. Rust pode parecer mais expl\u00edcito em certos aspectos (como o uso de mut para vari\u00e1veis mut\u00e1veis), mas isso tamb\u00e9m ajuda na legibilidade ao indicar claramente a mutabilidade."},{"location":"4_legibilidade/#ortogonalidade","title":"Ortogonalidade","text":"Rust promove uma boa ortogonalidade, onde combina\u00e7\u00f5es de conceitos primitivos s\u00e3o significativas e consistentes. Isso significa que conceitos como propriedades de mutabilidade, gerenciamento de mem\u00f3ria e seguran\u00e7a s\u00e3o tratados de forma consistente em todo o c\u00f3digo. <p>Em Rust:</p> <pre><code>struct Pessoa {\n    nome: String,\n    idade: u32,\n}\n\nimpl Pessoa {\n    fn novo(nome: String, idade: u32) -&gt; Self {\n        Pessoa { nome, idade }\n    }\n\n    fn cumprimentar(&amp;self) {\n        println!(\"Ol\u00e1, meu nome \u00e9 {} e eu tenho {} anos.\", self.nome, self.idade);\n    }\n}\n\nfn main() {\n    let mut pessoa = Pessoa::novo(String::from(\"Alice\"), 30); // cria\u00e7\u00e3o de uma inst\u00e2ncia de Pessoa\n    pessoa.cumprimentar(); // chamada de m\u00e9todo imut\u00e1vel\n}\n\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Pessoa {\nprivate:\n    std::string nome;\n    int idade;\n\npublic:\n    Pessoa(std::string nome, int idade) : nome(nome), idade(idade) {}\n\n    void cumprimentar() const {\n        std::cout &lt;&lt; \"Ol\u00e1, meu nome \u00e9 \" &lt;&lt; nome &lt;&lt; \" e eu tenho \" &lt;&lt; idade &lt;&lt; \" anos.\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Pessoa pessoa(\"Alice\", 30); // cria\u00e7\u00e3o de uma inst\u00e2ncia de Pessoa\n    pessoa.cumprimentar(); // chamada de m\u00e9todo constante\n    return 0;\n}\n</code></pre> Em ambos exemplos, a ortogonalidade \u00e9 evidente na forma como Rust e C++ lidam com os conceitos fundamentais de orienta\u00e7\u00e3o a objetos e gerenciamento de recursos. Rust imp\u00f5e regras rigorosas para garantir seguran\u00e7a e preven\u00e7\u00e3o de erros, enquanto C++ oferece mais flexibilidade, mas requer maior responsabilidade do programador para garantir a seguran\u00e7a e a efici\u00eancia do c\u00f3digo."},{"location":"4_legibilidade/#instrucoes-de-controle","title":"Instru\u00e7\u00f5es de Controle","text":"Rust evita constru\u00e7\u00f5es como goto que podem complicar o fluxo de controle. Em vez disso, incentiva o uso de estruturas de controle mais seguras e previs\u00edveis, como if, match e loops. <p>Em Rust:</p> <pre><code>fn main() {\n    let numero = 42;\n\n    if numero &lt; 0 {\n        println!(\"O n\u00famero \u00e9 negativo\");\n    } else if numero &gt; 0 {\n        println!(\"O n\u00famero \u00e9 positivo\");\n    } else {\n        println!(\"O n\u00famero \u00e9 zero\");\n    }\n\n    let resposta = match numero {\n        0 =&gt; \"Zero\",\n        1 =&gt; \"Um\",\n        _ =&gt; \"Outro\",\n    };\n\n    println!(\"Resposta: {}\", resposta);\n\n    for i in 0..5 {\n        println!(\"Itera\u00e7\u00e3o {}\", i);\n    }\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int numero = 42;\n\n    if (numero &lt; 0) {\n        std::cout &lt;&lt; \"O n\u00famero \u00e9 negativo\" &lt;&lt; std::endl;\n    } else if (numero &gt; 0) {\n        std::cout &lt;&lt; \"O n\u00famero \u00e9 positivo\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"O n\u00famero \u00e9 zero\" &lt;&lt; std::endl;\n    }\n\n    switch (numero) {\n        case 0:\n            std::cout &lt;&lt; \"Zero\" &lt;&lt; std::endl;\n            break;\n        case 1:\n            std::cout &lt;&lt; \"Um\" &lt;&lt; std::endl;\n            break;\n        default:\n            std::cout &lt;&lt; \"Outro\" &lt;&lt; std::endl;\n            break;\n    }\n\n    for (int i = 0; i &lt; 5; ++i) {\n        std::cout &lt;&lt; \"Itera\u00e7\u00e3o \" &lt;&lt; i &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li> <p> if, else if, else versus if, else if, else: Tanto em Rust quanto em C++, a estrutura condicional if, else if, else \u00e9 utilizada para ramificar o fluxo de controle com base em condi\u00e7\u00f5es. Rust e C++ s\u00e3o bastante semelhantes nesse aspecto, promovendo clareza na express\u00e3o das condi\u00e7\u00f5es. </p> </li> <li> <p> match vs switch: Em Rust, match \u00e9 uma express\u00e3o poderosa que cobre todas as possibilidades de um valor de maneira segura e exaustiva. No exemplo, _ \u00e9 usado para capturar todos os outros casos n\u00e3o especificados. Em C++, switch \u00e9 usado para a mesma finalidade, mas requer explicitamente um break para evitar a execu\u00e7\u00e3o cont\u00ednua de casos subsequentes. </p> </li> <li> <p> Loops: Ambas as linguagens suportam loops for para iterar sobre uma faixa de valores. Rust usa .. para gerar uma faixa exclusiva (0 at\u00e9 4 no exemplo), enquanto C++ usa &lt; para definir a condi\u00e7\u00e3o de t\u00e9rmino do loop. </p> </li> </ul> Rust, ao evitar constru\u00e7\u00f5es como goto, promove um c\u00f3digo mais estruturado e leg\u00edvel, incentivando o uso de constru\u00e7\u00f5es de controle mais seguras e expressivas. C++ oferece mais flexibilidade em algumas \u00e1reas, mas tamb\u00e9m permite o uso de goto, o que pode complicar o entendimento e a manuten\u00e7\u00e3o do c\u00f3digo, se mal utilizado. Em resumo, Rust e C++ proporcionam ferramentas poderosas para controle de fluxo, mas Rust, com suas abordagens mais modernas e restritivas, tende a promover pr\u00e1ticas de programa\u00e7\u00e3o mais seguras e leg\u00edveis, especialmente em cen\u00e1rios onde o controle de fluxo \u00e9 crucial para a clareza do c\u00f3digo."},{"location":"4_legibilidade/#tipos-de-dados-e-estruturas","title":"Tipos de Dados e Estruturas","text":"<p>Rust oferece tipos de dados poderosos e seguros, como enums, structs e tuples, que s\u00e3o \u00fateis e adequados para definir estruturas complexas de dados de forma clara e concisa.</p> <p>Em Rust:</p> <pre><code>// Definindo uma enumera\u00e7\u00e3o para representar diferentes tipos de formas geom\u00e9tricas\nenum Forma {\n    Retangulo { largura: u32, altura: u32 },\n    Circulo(f64),\n    Quadrado(u32),\n}\n\n// Definindo uma estrutura para representar uma pessoa\nstruct Pessoa {\n    nome: String,\n    idade: u8,\n}\n\n// Definindo uma tupla para armazenar coordenadas\nstruct Coordenadas(i32, i32);\n\nfn main() {\n    // Exemplos de uso dos tipos definidos\n    let retangulo = Forma::Retangulo { largura: 30, altura: 50 };\n    let circulo = Forma::Circulo(3.5);\n    let pessoa = Pessoa { nome: String::from(\"Alice\"), idade: 25 };\n    let coordenadas = Coordenadas(10, 20);\n\n    match retangulo {\n        Forma::Retangulo { largura, altura } =&gt; {\n            println!(\"Ret\u00e2ngulo: largura = {}, altura = {}\", largura, altura);\n        }\n        _ =&gt; {}\n    }\n\n    match circulo {\n        Forma::Circulo(raio) =&gt; {\n            println!(\"C\u00edrculo: raio = {}\", raio);\n        }\n        _ =&gt; {}\n    }\n\n    println!(\"Pessoa: {} tem {} anos.\", pessoa.nome, pessoa.idade);\n    println!(\"Coordenadas: ({}, {})\", coordenadas.0, coordenadas.1);\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n\n// Definindo uma enumera\u00e7\u00e3o para representar diferentes tipos de formas geom\u00e9tricas\nenum class Forma {\n    Retangulo,\n    Circulo,\n    Quadrado,\n};\n\n// Definindo uma estrutura para representar uma pessoa\nstruct Pessoa {\n    std::string nome;\n    unsigned int idade;\n};\n\n// Usando uma tupla para armazenar coordenadas\ntypedef std::tuple&lt;int, int&gt; Coordenadas;\n\nint main() {\n    // Exemplos de uso dos tipos definidos\n    Forma forma = Forma::Retangulo;\n    Pessoa pessoa = {\"Alice\", 25};\n    Coordenadas coordenadas = std::make_tuple(10, 20);\n\n    switch (forma) {\n        case Forma::Retangulo:\n            std::cout &lt;&lt; \"Ret\u00e2ngulo\" &lt;&lt; std::endl;\n            break;\n        case Forma::Circulo:\n            std::cout &lt;&lt; \"C\u00edrculo\" &lt;&lt; std::endl;\n            break;\n        case Forma::Quadrado:\n            std::cout &lt;&lt; \"Quadrado\" &lt;&lt; std::endl;\n            break;\n    }\n\n    std::cout &lt;&lt; \"Pessoa: \" &lt;&lt; pessoa.nome &lt;&lt; \" tem \" &lt;&lt; pessoa.idade &lt;&lt; \" anos.\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Coordenadas: (\" &lt;&lt; std::get&lt;0&gt;(coordenadas) &lt;&lt; \", \" &lt;&lt; std::get&lt;1&gt;(coordenadas) &lt;&lt; \")\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <ul> <li>Enums: Rust usa enums de forma poderosa, permitindo a defini\u00e7\u00e3o de variantes com dados associados, como Forma::Retangulo { largura, altura }. C++ tamb\u00e9m tem enums, mas n\u00e3o suporta dados associados sem o uso de classes.</li> <li>Structs: Ambas as linguagens suportam structs para definir estruturas de dados. Rust permite m\u00e9todos e implementa\u00e7\u00f5es diretamente associadas \u00e0s structs, enquanto em C++ \u00e9 necess\u00e1rio usar classes para isso.</li> <li>Tuples: Rust e C++ suportam tuples para agrupar m\u00faltiplos valores em um \u00fanico tipo. Rust usa a sintaxe (valor1, valor2) para criar e acessar tuples, enquanto C++ usa std::tuple e std::get para o mesmo prop\u00f3sito.</li> </ul> Rust se destaca na seguran\u00e7a e na expressividade de seus tipos de dados, garantindo que cada valor tenha um \u00fanico propriet\u00e1rio (propriedade de propriedade). Isso ajuda a prevenir erros comuns de gerenciamento de mem\u00f3ria, como vazamentos e refer\u00eancias inv\u00e1lidas. Em contraste, C++ oferece mais flexibilidade, mas com um custo maior em termos de gerenciamento de mem\u00f3ria seguro e legibilidade."},{"location":"4_legibilidade/#aspectos-da-sintaxe","title":"Aspectos da Sintaxe","text":"Rust possui uma sintaxe moderna que \u00e9 projetada para ser clara e expressiva. Por exemplo, utiliza palavras-chave claras e n\u00e3o sobrecarrega o uso de operadores especiais. Identificadores descritivos s\u00e3o incentivados, o que melhora a legibilidade. Comparando com C++, Rust muitas vezes pode parecer mais verboso em certos aspectos (como o uso de mut para indicar mutabilidade), mas essa verbosidade tamb\u00e9m pode melhorar a legibilidade ao tornar as inten\u00e7\u00f5es do c\u00f3digo mais claras. C++ tende a ser mais flex\u00edvel em alguns aspectos, mas essa flexibilidade pode levar a c\u00f3digos menos leg\u00edveis se n\u00e3o for usada com cuidado. Em resumo, Rust foi projetado com foco na legibilidade, seguran\u00e7a e performance, procurando equilibrar simplicidade com poder. Embora seja diferente de C++ em muitos aspectos, ambos t\u00eam seus m\u00e9ritos e s\u00e3o capazes de produzir c\u00f3digo leg\u00edvel, desde que os desenvolvedores sigam boas pr\u00e1ticas de codifica\u00e7\u00e3o."},{"location":"5_escrita/","title":"Capacidade de Escrita","text":""},{"location":"5_escrita/#simplicidade-e-ortogonalidade","title":"Simplicidade e Ortogonalidade","text":"Rust \u00e9 projetada com poucos componentes b\u00e1sicos e regras consistentes para combin\u00e1-los, o que facilita a aprendizagem e a escrita de c\u00f3digo robusto. A ortogonalidade em Rust \u00e9 moderada; ela enfatiza a seguran\u00e7a e o gerenciamento de mem\u00f3ria seguro, o que pode requerer um pouco mais de entendimento para programadores novatos, mas traz benef\u00edcios significativos em termos de preven\u00e7\u00e3o de erros."},{"location":"5_escrita/#suporte-para-abstracao","title":"Suporte para Abstra\u00e7\u00e3o","text":"Rust oferece suporte robusto para abstra\u00e7\u00e3o de dados e processo e possui suporte para classes e registros. Ela permite a defini\u00e7\u00e3o de estruturas complexas e opera\u00e7\u00f5es abstratas atrav\u00e9s de mecanismos como traits (tra\u00e7os) e enums, o que facilita a express\u00e3o de ideias complexas de forma clara e segura. <p>Em Rust:</p> <pre><code>trait Animal {\n    fn make_sound(&amp;self);\n}\n\nstruct Dog;\nimpl Animal for Dog {\n    fn make_sound(&amp;self) {\n        println!(\"Woof!\");\n    }\n}\n\nfn main() {\n    let dog = Dog;\n    dog.make_sound();\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void make_sound() = 0;\n};\n\nclass Dog : public Animal {\npublic:\n    void make_sound() override {\n        cout &lt;&lt; \"Woof!\" &lt;&lt; endl;\n    }\n};\n\nint main() {\n    Dog dog;\n    dog.make_sound();\n    return 0;\n}\n</code></pre> Rust suporta abstra\u00e7\u00e3o com traits, permitindo definir comportamentos comuns que podem ser implementados por diferentes tipos de dados de forma segura."},{"location":"5_escrita/#expressividade","title":"Expressividade","text":"Rust \u00e9 conhecida por sua expressividade, proporcionando formas convenientes de especificar computa\u00e7\u00f5es. Seu sistema de tipos forte e sua infer\u00eancia de tipos ajudam a reduzir a sobrecarga de escrita de c\u00f3digo repetitivo. C++ oferece expressividade atrav\u00e9s de funcionalidades como sobrecarga de operadores e templates, mas pode resultar em c\u00f3digo mais verboso e propenso a erros. <p>Em Rust:</p> <pre><code>fn main() {\n    let numbers = vec![1, 2, 3, 4, 5];\n\n    let sum: i32 = numbers.iter().sum();\n    let squares: Vec&lt;i32&gt; = numbers.iter().map(|&amp;x| x * x).collect();\n\n    println!(\"Sum: {}\", sum);\n    println!(\"Squares: {:?}\", squares);\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};\n\n    int sum = accumulate(numbers.begin(), numbers.end(), 0);\n\n    vector&lt;int&gt; squares;\n    transform(numbers.begin(), numbers.end(), back_inserter(squares), [](int x) { return x * x; });\n\n    cout &lt;&lt; \"Sum: \" &lt;&lt; sum &lt;&lt; endl;\n    cout &lt;&lt; \"Squares: \";\n    for (int num : squares) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> Ambos exemplos mostram como Rust e C++ podem ser expressivos ao manipular dados e realizar computa\u00e7\u00f5es. Rust se destaca pela sua sintaxe mais moderna e segura, especialmente ao lidar com manipula\u00e7\u00e3o de cole\u00e7\u00f5es e closures. Por outro lado, C++ oferece uma rica biblioteca padr\u00e3o (STL) que permite realizar tarefas similares, mas com uma sintaxe que pode exigir mais c\u00f3digo para atingir o mesmo resultado. Em termos de capacidade de escrita, Rust geralmente proporciona uma experi\u00eancia mais fluida, especialmente para desenvolvedores que valorizam a preven\u00e7\u00e3o de erros e a clareza do c\u00f3digo."},{"location":"5_escrita/#sintaxe","title":"Sintaxe","text":"A sintaxe em Rust \u00e9 projetada para ser expressiva, usando um sistema de empr\u00e9stimos (passagem por refer\u00eancia) e movimentos que ajuda a evitar problemas comuns de gerenciamento de mem\u00f3ria, bem como instru\u00e7\u00f5es de infer\u00eancia de tipo que auxiliam na capacidade de escrita.  C++ tem uma sintaxe flex\u00edvel, mas pode ser mais verbosa e menos segura se n\u00e3o for utilizada corretamente, especialmente em rela\u00e7\u00e3o ao gerenciamento de mem\u00f3ria. <p>Em Rust:</p> <pre><code>#[derive(Debug)] // utilizado para inferir como imprimir a struct\nstruct Car {\n    brand: String,\n    model: String,\n    year: u32,\n}\n\n// Fun\u00e7\u00e3o que calcula o pre\u00e7o estimado com base no ano do carro\nfn calculate_price(car: &amp;Car) -&gt; u32 {\n    let base_price = 10_000; // Pre\u00e7o base arbitr\u00e1rio\n\n    // Calculando o pre\u00e7o com base no ano do carro\n    let depreciation = (2024 - car.year) * 100; // Deprecia\u00e7\u00e3o arbitr\u00e1ria por ano\n    base_price - depreciation\n}\n\nfn main() {\n    // Criando um carro\n    let my_car = Car {\n        brand: String::from(\"Toyota\"),\n        model: String::from(\"Corolla\"),\n        year: 2018,\n    };\n\n    // Chamando a fun\u00e7\u00e3o calculate_price e passando uma refer\u00eancia emprestada para my_car\n    let estimated_price = calculate_price(&amp;my_car);\n\n    println!(\n        \"O pre\u00e7o estimado do {} {} de {} \u00e9 de {} reais.\",\n        my_car.brand, my_car.model, my_car.year, estimated_price\n    );\n    println!(\"{:?}\", my_car);\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// Definindo uma estrutura de dados simples\nstruct Car {\n    std::string brand;\n    std::string model;\n    int year;\n};\n\n// Fun\u00e7\u00e3o que calcula o pre\u00e7o estimado com base no ano do carro\nint calculate_price(const Car&amp; car) {\n    int base_price = 10000; // Pre\u00e7o base arbitr\u00e1rio\n\n    // Calculando o pre\u00e7o com base no ano do carro\n    int depreciation = (2024 - car.year) * 100; // Deprecia\u00e7\u00e3o arbitr\u00e1ria por ano\n    return base_price - depreciation;\n}\n\nint main() {\n    // Criando um carro\n    Car my_car = {\"Toyota\", \"Corolla\", 2018};\n\n    // Chamando a fun\u00e7\u00e3o calculate_price e passando uma refer\u00eancia constante para my_car\n    int estimated_price = calculate_price(my_car);\n\n    std::cout &lt;&lt; \"O pre\u00e7o estimado do \" &lt;&lt; my_car.brand &lt;&lt; \" \" &lt;&lt; my_car.model &lt;&lt; \" de \" &lt;&lt; my_car.year\n              &lt;&lt; \" \u00e9 de \" &lt;&lt; estimated_price &lt;&lt; \" reais.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n\n</code></pre>"},{"location":"6_confiabilidade/","title":"Confiabilidade","text":""},{"location":"6_confiabilidade/#verificacao-de-tipos","title":"Verifica\u00e7\u00e3o de Tipos","text":"Rust realiza verifica\u00e7\u00e3o de tipos em tempo de compila\u00e7\u00e3o de forma ainda mais rigorosa do que o C++, verificando tamb\u00e9m propriedades como a mutabilidade de uma vari\u00e1vel e a reutiliza\u00e7\u00e3o dela em outras partes do c\u00f3digo. <p>Em Rust:</p> <pre><code>fn main() {\n    let x: i32 = \"hello\"; // Erro de tipo: esperava i32, encontrou &amp;str\n    x = 64; // Erro do tipo: n\u00e3o pode haver atribui\u00e7\u00e3o dupla em uma vari\u00e1vel imut\u00e1vel (por padr\u00e3o, todas as vari\u00e1veis s\u00e3o imut\u00e1veis.\n    println!(\"Hello, world!\");\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = \"hello\"; // Erro de tipo: convers\u00e3o de const char* para int\n    cout &lt;&lt; \"Hello, world!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"6_confiabilidade/#tratamento-de-excecoes","title":"Tratamento de Exce\u00e7\u00f5es","text":"Rust utiliza o conceito de Resultados (Result) para lidar com erros de forma expl\u00edcita, evitando exce\u00e7\u00f5es tradicionais, o que promove um c\u00f3digo mais previs\u00edvel e menos propenso a falhas inesperadas. <p>Em Rust:</p> <pre><code>fn main() -&gt; Result&lt;(), String&gt; {\n    let result: Result&lt;i32, String&gt; = Err(\"Erro ao processar\".to_string());\n    match result {\n        Ok(value) =&gt; println!(\"Valor: {}\", value),\n        Err(msg) =&gt; println!(\"Erro: {}\", msg),\n    }\n    Ok(())\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Erro ao processar\");\n    } catch (const exception&amp; e) {\n        cout &lt;&lt; \"Erro: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"6_confiabilidade/#aliasing","title":"Aliasing","text":"Rust \u00e9 forte na preven\u00e7\u00e3o de problemas de aliasing atrav\u00e9s do sistema de propriedade (ownership) e empr\u00e9stimos (borrowing). Esses conceitos garantem que apenas uma refer\u00eancia mut\u00e1vel ou v\u00e1rias refer\u00eancias imut\u00e1veis possam existir para um \u00fanico dado recurso ao mesmo tempo, reduzindo a possibilidade de erros relacionados a aliasing. <p>Em Rust:</p> <pre><code>fn main() {\n    let mut x = 5;\n    let y = &amp;mut x;\n    let z = &amp;mut x; // Erro: n\u00e3o \u00e9 permitido ter m\u00faltiplas refer\u00eancias mut\u00e1veis\n    *y += 1;\n    println!(\"x: {}\", x);\n}\n</code></pre> <p>Em C++:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int x = 5;\n    int&amp; y = x;\n    int&amp; z = x; // Compilador permite m\u00faltiplas refer\u00eancias\n    y += 1;\n    cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"7_custo/","title":"Custos","text":""},{"location":"7_custo/#custo-de-treinamento","title":"Custo de Treinamento","text":""},{"location":"7_custo/#simplicidade-e-ortogonalidade-da-linguagem","title":"Simplicidade e Ortogonalidade da Linguagem","text":"Rust tende a ter uma curva de aprendizado mais acentuada devido ao seu sistema de tipos avan\u00e7ado e regras de empr\u00e9stimos. No entanto, sua ortogonalidade e consist\u00eancia na forma como esses conceitos s\u00e3o aplicados podem tornar a linguagem mais previs\u00edvel e menos propensa a erros relacionados \u00e0 seguran\u00e7a de mem\u00f3ria."},{"location":"7_custo/#experiencia-dos-programadores","title":"Experi\u00eancia dos Programadores","text":"A experi\u00eancia dos programadores em Rust pode variar significativamente. Programadores com experi\u00eancia em linguagens de sistemas (como C/C++) podem achar mais f\u00e1cil migrar para Rust devido a semelhan\u00e7as em paradigmas, enquanto programadores sem essa experi\u00eancia podem enfrentar um desafio maior devido \u00e0s novas abstra\u00e7\u00f5es, passagens por refer\u00eancia e forte tipagem."},{"location":"7_custo/#custo-para-escrever-programas","title":"Custo para Escrever Programas","text":""},{"location":"7_custo/#capacidade-de-escrita-e-adequacao-a-aplicacao-particular","title":"Capacidade de Escrita e Adequa\u00e7\u00e3o \u00e0 Aplica\u00e7\u00e3o Particular","text":"Essa linguagem \u00e9 conhecida por sua seguran\u00e7a e performance, sendo adequada para sistemas onde esses aspectos s\u00e3o cr\u00edticos, como em sistemas embarcados ou servi\u00e7os de alto desempenho. A sua expressividade e ferramentas modernas de abstra\u00e7\u00e3o ajudam na escrita de grandes projetos."},{"location":"7_custo/#custo-para-compilar-programas","title":"Custo para Compilar Programas","text":""},{"location":"7_custo/#nivel-de-otimizacao-do-codigo","title":"N\u00edvel de Otimiza\u00e7\u00e3o do C\u00f3digo","text":"A linguagem \u00e9 projetada para proporcionar um bom equil\u00edbrio entre tamanho do c\u00f3digo e velocidade de execu\u00e7\u00e3o, gra\u00e7as ao seu sistema de gerenciamento de mem\u00f3ria e ao compilador LLVM, que realiza otimiza\u00e7\u00f5es autom\u00e1ticas significativas. A compila\u00e7\u00e3o de um grande projeto \u00e9 relativamente custosa e demorada devido ao grande n\u00famero de verifica\u00e7\u00f5es realizadas nessa etapa."},{"location":"7_custo/#custo-para-executar-programas","title":"Custo para Executar Programas","text":""},{"location":"7_custo/#projeto-da-linguagem","title":"Projeto da Linguagem","text":"Rust inclui verifica\u00e7\u00e3o forte de tipos em tempo de compila\u00e7\u00e3o e isso ajuda a reduzir erros e falhas de seguran\u00e7a que poderiam ocorrer durante a execu\u00e7\u00e3o do programa. Entretanto, como dito anteriormente, essa forte verifica\u00e7\u00e3o causa lentid\u00e3o em c\u00f3digos maiores, o que pode ser uma desvantagem a depender da aplica\u00e7\u00e3o."},{"location":"8_outros/","title":"Outros","text":""},{"location":"8_outros/#qualidade-da-definicao-gramatica","title":"Qualidade da Defini\u00e7\u00e3o (Gram\u00e1tica)","text":"Rust possui ampla documenta\u00e7\u00e3o, que pode ser acessada no site oficial da linguagem. Escrita em linguagem de f\u00e1cil interpreta\u00e7\u00e3o, temos neste documento informa\u00e7\u00f5es precisas e detalhadas acerca de sua gram\u00e1tica e sintaxe. Na gram\u00e1tica de Rust est\u00e3o inclusos guias, tutoriais e refer\u00eancias, que podem ser de grande utilidade para os desenvolvedores. Ademais, a linguagem de programa\u00e7\u00e3o em quest\u00e3o possui, atualmente, uma comunidade bastante ativa, que colabora para o crescimento e a amplia\u00e7\u00e3o do uso da mesma."},{"location":"8_outros/#generalidade","title":"Generalidade","text":"Rust \u00e9 uma linguagem de programa\u00e7\u00e3o altamente vers\u00e1til, podendo ser utilizada em uma ampla gama de aplica\u00e7\u00f5es. Esta flexibilidade \u00e9 evidenciada em diversos dom\u00ednios. <ul> <li> <p>Desenvolvimento de Sistemas: Devido a seu controle sobre recursos e desempenho, a linguagem pode ser utilizada para o desenvolvimento de sistemas operacionais, drivers e softwares de baixo n\u00edvel em geral.</p> </li> <li> <p>Desenvolvimento Web: Com o suporte a WebAssembly, Rust \u00e9 uma escolha excelente para desenvolver aplica\u00e7\u00f5es web que requerem alto desempenho. Sua capacidade de compilar c\u00f3digo Rust para Wasm permite que desenvolvedores criem aplica\u00e7\u00f5es web r\u00e1pidas e eficientes, competindo diretamente com linguagens tradicionalmente usadas no desenvolvimento dessas tarefas.</p> </li> <li> <p>Aplica\u00e7\u00f5es de Rede: Rust possui uma biblioteca padr\u00e3o poderosa e um ecossistema de crates bem estabelecido, que facilita o desenvolvimento de servidores, protocolos de rede e sistemas distribu\u00eddos. Por possuir excelente desempenho no contexto da seguran\u00e7a e concorr\u00eancia eficiente dos projetos, se tornou uma escolha popular na cria\u00e7\u00e3o de sistemas que exigem comunica\u00e7\u00e3o robusta pela rede.</p> </li> <li> <p>Programa\u00e7\u00e3o de Jogos: Na ind\u00fastria de jogos, Rust vem ganhando destaque devido a seu desempenho pr\u00f3ximo ao de outras linguagens de baixo n\u00edvel, como C++, e sua seguran\u00e7a, respons\u00e1vel por evitar erros comuns.</p> </li> <li> <p>Ferramentas e Aplica\u00e7\u00f5es de Utilidade Geral: Al\u00e9m dos dom\u00ednios mencionados, Rust \u00e9 aplic\u00e1vel em uma ampla variedade de outras \u00e1reas, como ferramentas de desenvolvimento, an\u00e1lise de dados, sistemas embarcados, computa\u00e7\u00e3o distribu\u00edda e muito mais.</p> </li> </ul>"},{"location":"8_outros/#portabilidade","title":"Portabilidade","text":"Rust oferece boa portabilidade, suportando diversas plataformas e ambientes. Sua capacidade de adapta\u00e7\u00e3o a diferentes sistemas \u00e9 uma das interessante caracter\u00edstica abordada pela linguagem. <ul> <li> <p>Suporte Multiplataforma: Rust pode ser compilada para diversos sistemas operacionais, incluindo Windows, macOS e Linux. Isso permite que desenvolvedores criem aplica\u00e7\u00f5es que funcionem de maneira consistente em diferentes plataformas.</p> </li> <li> <p>Suporte a Arquiteturas Diversas: Rust suporta v\u00e1rias arquiteturas, como x86, ARM e WebAssembly (Wasm), permitindo a cria\u00e7\u00e3o de projetos com capacidade de execu\u00e7\u00e3o de maneira direta em navegadores web.</p> </li> <li> <p>Camada de Abstra\u00e7\u00e3o de Hardware: Esta camada, de sigla HAL, \u00e9 uma ferramenta presente em Rust que ajuda a escrever c\u00f3digo capaz de funcionar em diferentes tipos de hardware. Para que n\u00e3o seja necess\u00e1ria a escrita de c\u00f3digos diferentes para cada dispositivo, a HAL fornece um conjunto de regras e fun\u00e7\u00f5es padr\u00e3o. Com isso, \u00e9 poss\u00edvel utilizar o mesmo c\u00f3digo para controlar diferentes componentes de hardware (como pinos, sensores, e displays), sem se preocupar com as especificidades de cada um. De maneira resumida, a camada de abstra\u00e7\u00e3o de hardware age como uma tradu\u00e7\u00e3o, que torna a utiliza\u00e7\u00e3o do c\u00f3digo em diversos dispositivos mais f\u00e1cil.</p> </li> <li> <p>Cross-Compiling: A ferramenta rustup \u00e9 respons\u00e1vel por facilitar a instala\u00e7\u00e3o e gest\u00e3o de diferentes vers\u00f5es de Rust, al\u00e9m de suport o cross-compiling, que permite que o c\u00f3digo seja compilado para diferentes plataformas a partir de uma \u00fanica m\u00e1quina de desenvolvimento.</p> </li> </ul>"},{"location":"8_outros/#interoperabilidade","title":"Interoperabilidade","text":"<p>Rust oferece diversas formas de interoperabilidade com outras linguagens e sistemas, o que facilita a integrar a linguagem a projetos previamente existentes e tecnologias variadas.</p> <ul> <li> <p>Integra\u00e7\u00e3o com Sistemas de Constru\u00e7\u00e3o: Rust pode ser integrado a sistemas de constru\u00e7\u00e3o existentes, como make ou cmake. Combinandos com Cargo, esses sistemas podem gerenciar a constru\u00e7\u00e3o e o processo de compila\u00e7\u00e3o. Com isso, Rust pode ser utilizado em projetos que j\u00e1 possuem outras ferramentas de constru\u00e7\u00e3o.</p> </li> <li> <p>Interoperabilidade com C\u00f3digo C: Rust pode interagir com c\u00f3digo C, permitindo que o desenvolvedor utilize fun\u00e7\u00f5es e dados de bibliotecas C em seus projetos Rust. Para isso, \u00e9 utilizado um mecanismo que converte tipos de dados entre Rust e C, a fim de que possam ser compreendidos por ambas linguagens. Esse processo envolve definir como os dados s\u00e3o trocados e como as fun\u00e7\u00f5es C podem ser chamadas a partir de Rust. A partir deste processo, \u00e9 poss\u00edvel simplificar a integra\u00e7\u00e3o de c\u00f3digo Rust com bibliotecas C existentes, bem como utilizar c\u00f3digo de sistemas legados.</p> </li> </ul>"},{"location":"bibliografia/","title":"Refer\u00eancias Bibliogr\u00e1ficas","text":"<ol> <li> <p>RUST BR. The Rust Programming Language. Dispon\u00edvel em: https://rust-br.github.io/rust-book-pt-br/. Acesso em: 10 jul. 2024.</p> </li> <li> <p>SALINAS, Andr\u00e9. Gerenciamento de mem\u00f3ria em Rust. Dispon\u00edvel em: https://www.tabnews.com.br/salinas/gerenciamento-de-memoria-em-rust. Acesso em: 10 jul. 2024.</p> </li> <li> <p>DIEGO, Higor. Rust: Tipos de dados. Dispon\u00edvel em: https://higordiego.medium.com/rust-tipos-de-dados-1c72fd4a0c6d. Acesso em: 10 jul. 2024.</p> </li> <li> <p>RUST BR. Tipos primitivos compostos em Rust. Dispon\u00edvel em: https://rust-br.github.io/rust-book-pt-br/ch03-02-data-types.html. Acesso em: 10 jul. 2024.</p> </li> <li> <p>RUST LANG. Reserved keywords. Dispon\u00edvel em: https://doc.rust-lang.org/reference/keywords.html#reserved-keywords. Acesso em: 10 jul. 2024.</p> </li> <li> <p>RUST LANG. Visibility and privacy. Dispon\u00edvel em: https://doc.rust-lang.org/reference/visibility-and-privacy.html. Acesso em: 10 jul. 2024.</p> </li> <li> <p>EXIMIA. Como a linguagem Rust garante que erros sejam tratados. Dispon\u00edvel em: https://eximia.co/como-a-linguagem-rust-garante-que-erros-sejam-tratados/. Acesso em: 10 jul. 2024.</p> </li> <li> <p>PAULO. Diferen\u00e7as na propaga\u00e7\u00e3o e tratamentos de erros em Rust, Golang e Java. Dispon\u00edvel em: https://xxpauloxx.com.br/diferen%C3%A7as-na-propaga%C3%A7%C3%A3o-e-tratamentos-de-erros-em-rust-golang-e-java-ef8975300bc. Acesso em: 10 jul. 2024.</p> </li> <li> <p>TABNEWS. O \"Hello World\" de Rust que voc\u00ea nunca viu: Entendendo Rust. Dispon\u00edvel em: https://www.tabnews.com.br/coffeeispower/o-hello-world-de-rust-que-voce-nunca-viu-entendendo-rust. Acesso em: 10 jul. 2024.</p> </li> <li> <p>RUST EMBEDDED. Interoperability. Dispon\u00edvel em: https://docs.rust-embedded.org/book/interoperability/index.html. Acesso em: 10 jul. 2024.</p> </li> <li> <p>RUST EMBEDDED. Portability. Dispon\u00edvel em: https://docs.rust-embedded.org/book/portability/index.html. Acesso em: 10 jul. 2024.</p> </li> </ol>"}]}